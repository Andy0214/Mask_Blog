<!DOCTYPE html>
<html>
<head>
<title>2016a</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>2016游戏安全技术竞赛Android第一题</h2>
<hr />
<p>apk下载地址</p>
<p><a href="http://gslab.qq.com/competition/firstTurn.shtml">http://gslab.qq.com/competition/firstTurn.shtml</a></p>
<hr />
<pre><code>package com.tencent.tencent2016a;

import android.app.AlertDialog$Builder;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.a.f;
import android.widget.Button;
import android.widget.EditText;
import com.a.a.e.a.a;
import com.a.a.e.a.b;

public class MainActivity extends f {
Button o;
Button p;
EditText editText;
EditText editText2;
AlertDialog$Builder s;

static {
    System.loadLibrary(&quot;CheckRegister&quot;);
}

public MainActivity() {
    super();
    this.o = null;
    this.p = null;
    this.editText = null;
    this.editText2 = null;
    this.s = null;
}

public native int NativeCheckRegister(String arg1, String arg2) {
}

protected void onActivityResult(int requestCode, int resultCode, Intent arg6) {
    b v0 = a.a(requestCode, resultCode, arg6);
    if(v0 == null) {
        super.onActivityResult(requestCode, resultCode, arg6);
    }
    else if(v0.a() != null) {
        String[] v0_1 = v0.a().split(&quot;:&quot;);
        this.editText.setText(v0_1[0]);
        this.editText2.setText(v0_1[1]);
    }
}

protected void onCreate(Bundle arg4) {
    super.onCreate(arg4);
    this.setContentView(2130968601);
    this.editText = this.findViewById(2131558472);
    this.editText2 = this.findViewById(2131558473);
    this.o = this.findViewById(2131558474);  // button
    this.s = new AlertDialog$Builder(((Context)this)); //新建一个对话框
    this.p = this.findViewById(2131558475);  // btnScan
    this.s.setMessage(&quot;Check Result&quot;); //对话框设置信息
    this.s.setTitle(&quot;Check Result&quot;); //对话框设置标题
    this.s.setPositiveButton(&quot;OK&quot;, new com.tencent.tencent2016a.a(this)); //对话框设置按钮和点击事件
    if(this.p != null) {
        this.p.setOnClickListener(new com.tencent.tencent2016a.b(this));
    }

    if(this.o != null) {
        this.o.setOnClickListener(new c(this));//关键事件
    }
}
}
</code></pre>

<p>分析完后，跟进c类进行查看：</p>
<pre><code>package com.tencent.tencent2016a;

import android.view.View$OnClickListener;
import android.view.View;

class c implements View$OnClickListener {
c(MainActivity arg1) {
    this.a = arg1;
    super();
}

public void onClick(View arg5) {
    String v0 = this.a.editText.getText().toString();  // Name
    String v1 = this.a.editText2.getText().toString();  // Passwd
    if(v0.length() &lt; 6 || v0.length() &gt; 20) { //Name在6-20之间
        this.a.s.setMessage(&quot;Name too short(&lt;6) or too long(&gt;20)!&quot;);
    }
    else if(1 == this.a.NativeCheckRegister(v0, v1)) {
        this.a.s.setMessage(&quot;Check Success!&quot;);
    }
    else {
        this.a.s.setMessage(&quot;Check Fail!&quot;);
    }

    this.a.s.create().show();
}
}
</code></pre>

<p>那么思路很明确了，要下面条件成立：</p>
<pre><code>1 == this.a.NativeCheckRegister(v0, v1))
</code></pre>

<p>用IDA打开so文件：</p>
<p>F5大法好，等啥时候我不依靠F5了（等吧23333）</p>
<pre><code>int __fastcall Java_com_tencent_tencent2016a_MainActivity_NativeCheckRegister(int a1, int a2, int a3, int a4)
{
  int v4; // r7@1
  int v5; // r5@1
  int v6; // r4@1
  int v7; // r6@1
  int v8; // ST00_4@1
  int v9; // ST04_4@1

  v4 = a3;
  v5 = a4;
  v6 = a1;
  v7 = (*(int (__cdecl **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a3, 0);
  v8 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v6 + 676))(v6, v5, 0);
  v9 = sub_1634(v7, v8);
  (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v6 + 680))(v6, v4, v7);
  (*(void (__fastcall **)(int, int, int))(*(_DWORD *)v6 + 680))(v6, v5, v8);
  return v9;
}
</code></pre>

<p>手动修复一下参数和方法和变量名，如下：</p>
<pre><code>int __fastcall Java_com_tencent_tencent2016a_MainActivity_NativeCheckRegister(JNIEnv *a1, jclass a2, jstring Name, jstring Passwd)
{
  jstring v4; // r7@1
  jstring v5; // r5@1
  JNIEnv *v6; // r4@1
  const char *Name_I; // r6@1
  const char *Pass_I; // ST00_4@1
  int v9; // ST04_4@1

  v4 = Name;
  v5 = Passwd;
  v6 = a1;
  Name_I = (*a1)-&gt;GetStringUTFChars(a1, Name, 0);
  Pass_I = (*v6)-&gt;GetStringUTFChars(v6, v5, 0);
  v9 = sub_1634(Name_I, (int)Pass_I);
  (*v6)-&gt;ReleaseStringUTFChars(v6, v4, Name_I);
  (*v6)-&gt;ReleaseStringUTFChars(v6, v5, Pass_I);
  return v9;// 要让v9==1
}
</code></pre>

<p>那么，继续跟进sub_1634方法，这里一段一段来分析：</p>
<pre><code>int __fastcall sub_1634(const char *a1, int a2)  //这里参数识别应该是char*a2
{
  int v2; // r6@1
  signed int v3; // r5@1
  int result; // r0@2
  signed int v5; // r4@3
  char *v6; // r7@4
  int v7; // r3@4
  int v8; // r4@6
  int v9; // r4@7
  int v10; // r1@8
  const char *v11; // [sp+Ch] [bp-464h]@1
  int v12[5]; // [sp+18h] [bp-458h]@7
  char v13[20]; // [sp+2Ch] [bp-444h]@7
  char s[20]; // [sp+40h] [bp-430h]@3
  char v15[936]; // [sp+54h] [bp-41Ch]@5
  int v16; // [sp+454h] [bp-1Ch]@1

  v2 = a2;
  v11 = a1;
  v16 = _stack_chk_guard; //这是一种栈平衡的验证，因为如果栈不平衡，程序会发生异常
  v3 = j_j_strlen(a1);
  if ( (unsigned int)(v3 - 6) &gt; 0xE )
goto LABEL_18;
  j_j_memset(s, 0, 0x14u); //进行s数组的初始化
  v5 = 0;
  do
  {
v6 = &amp;s[v5];
v7 = v11[v5 % v3] * (v5 + 20160126) * v3;
++v5;
*(_DWORD *)v6 += v7;
  }
  while ( v5 != 16 );
</code></pre>

<p>稍作优化后，便于分析：</p>
<pre><code>int __fastcall sub_1634(const char *Name, char *Passwd)
{
  char *EPass; // r6@1
  signed int v3; // r5@1
  int result; // r0@2
  signed int j; // r4@3
  char *ps; // r7@4
  int v7; // r3@4
  int v8; // r4@6
  int i; // r4@7
  int Vpass; // r1@8
  const char *Ename; // [sp+Ch] [bp-464h]@1
  int FinName[5]; // [sp+18h] [bp-458h]@7
  int FinPass[5]; // [sp+2Ch] [bp-444h]@7
  char Vname[20]; // [sp+40h] [bp-430h]@3
  char passEncode[936]; // [sp+54h] [bp-41Ch]@5
  int v16; // [sp+454h] [bp-1Ch]@1

  EPass = Passwd;
  Ename = Name;
  v16 = _stack_chk_guard;
  v3 = j_j_strlen(Name);
  if ( (unsigned int)(v3 - 6) &gt; 0xE )   // 名字长度在6-20之间
goto LABEL_18;
  j_j_memset(Vname, 0, 0x14u);  // 初始化
  j = 0;
  do
  {
ps = &amp;Vname[j]; // 取址
v7 = Ename[j % v3] * (j + 20160126) * v3;
++j;
*(_DWORD *)ps += v7;
  }
  while ( j != 16 );
</code></pre>

<p>那么下面直接贴出全部修改后的：</p>
<pre><code>int __fastcall sub_1634(const char *Name, char *Passwd)
{
  char *EPass; // r6@1
  signed int v3; // r5@1
  int result; // r0@2
  signed int j; // r4@3
  char *ps; // r7@4
  int v7; // r3@4
  int v8; // r4@6
  int i; // r4@7
  int Vpass; // r1@8
  const char *Ename; // [sp+Ch] [bp-464h]@1
  int FinName[5]; // [sp+18h] [bp-458h]@7
  int FinPass[5]; // [sp+2Ch] [bp-444h]@7
  char Vname[20]; // [sp+40h] [bp-430h]@3
  char passEncode[936]; // [sp+54h] [bp-41Ch]@5
  int v16; // [sp+454h] [bp-1Ch]@1

  EPass = Passwd;
  Ename = Name;
  v16 = _stack_chk_guard;
  v3 = j_j_strlen(Name);
  if ( (unsigned int)(v3 - 6) &gt; 0xE )   // 名字长度在6-20之间
goto LABEL_18;
  j_j_memset(Vname, 0, 0x14u);  // 初始化
  j = 0;
  do
  {
ps = &amp;Vname[j]; // 取址
v7 = Ename[j % v3] * (j + 20160126) * v3;
++j;
*(_DWORD *)ps += v7;
  }
  while ( j != 16 );// 对Ename进行一种转换
  j_j_memset(passEncode, 0, 0x400u);// 初始化
  if ( EncodePass1((int)EPass) &gt; 1024 || (v8 = EncodePass2((int)passEncode, (int)EPass), v8 != 20) )
  {
LABEL_18:   // if不满足
result = 0;
  }
  else  // 继续
  {
j_j_memset(FinName, 0, 0x14u);  // 初始化
j_j_memset(FinPass, 0, 0x14u);  // 初始化
i = 0;
do
{
  Vpass = *(_DWORD *)&amp;passEncode[i * 4];
  FinName[i] = *(_DWORD *)&amp;Vname[i * 4] / 10;
  FinPass[i] = Vpass;
  ++i;
}
while ( i != 5 );
result = 0;
if ( FinPass[4] + FinName[0] == FinPass[2]
  &amp;&amp; FinPass[4] + FinName[0] + FinName[1] == 2 * FinPass[4]
  &amp;&amp; FinName[2] + FinPass[3] == FinPass[0]
  &amp;&amp; FinName[2] + FinPass[3] + FinName[3] == 2 * FinPass[3] )
{
  result = (unsigned int)(FinName[4] + FinPass[1] - 3 * FinName[2]) &lt;= 0;// 要让result ==1
}
  }
  if ( v16 != _stack_chk_guard )// 栈不平衡
j_j___stack_chk_fail(result);
  return result;
}
</code></pre>

<p>这里有一个地方需要注意，那就是IDA的参数识别问题：</p>
<p><img src="./Image/1.png" /></p>
<p>这里分析下v13，他的每一个元素都是通过v10进行传递，总共传递了5次，也就是说，v13其实大小只有5，那么这里识别的v13[16]其实相对应的是v13[4]，那么我们修改下v13的大小，方便审读</p>
<p>那么双击v13，</p>
<p><img src="./Image/2.png" /></p>
<p>将它改为和上面一样，右键set type（或者快捷键Y）</p>
<p><img src="./Image/3.png" /></p>
<p>改为int类型数组5个长度即可：</p>
<p>修复完后</p>
<p><img src="./Image/4.png" /></p>
<p>然后还有就是一些参数类型识别的问题，char识别为int，int识别为char，分析一下修改就好了</p>
<p>从刚刚给出的修改后的代码可以分析：</p>
<p>我们要求Passwd,首先根据这个求出FinPass：</p>
<pre><code>if ( FinPass[4] + FinName[0] == FinPass[2]
  &amp;&amp; FinPass[4] + FinName[0] + FinName[1] == 2 * FinPass[4]
  &amp;&amp; FinName[2] + FinPass[3] == FinPass[0]
  &amp;&amp; FinName[2] + FinPass[3] + FinName[3] == 2 * FinPass[3] )
</code></pre>

<p>然后根据FinPass求出passEncode</p>
<pre><code>Vpass = *(_DWORD *)&amp;passEncode[i * 4];
  FinName[i] = *(_DWORD *)&amp;Vname[i * 4] / 10;
  FinPass[i] = Vpass;
  ++i;
</code></pre>

<p>最后，根据这个函数，求出我们输入的EPass</p>
<p><img src="./Image/5.png" /></p>
<p>跟进分析：</p>
<pre><code>int __fastcall EncodePass2(char *passEncode, char *EPass)
{
  char *v2; // r3@1
  int v3; // r3@3
  int v4; // r2@3
  int v5; // r5@3
  char *v6; // r3@4
  int v7; // r3@5
  int v8; // r6@5

  v2 = EPass;
  do
++v2;
  while ( (unsigned __int8)a456789[(unsigned __int8)*(v2 - 1)] &lt;= 0x3Fu );// a456789 == &quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@?456789:;&lt;=@@@@@@
  v3 = v2 - EPass;
  v4 = v3 - 1;
  v5 = 3 * ((v3 + 2) / 4);
  while ( 1 )
  {
v6 = passEncode;
if ( v4 &lt;= 4 )
  break;
v4 -= 4;
*passEncode = ((unsigned __int8)a456789[(unsigned __int8)EPass[1]] &gt;&gt; 4) | 4 * a456789[(unsigned __int8)*EPass];
passEncode[1] = ((unsigned __int8)a456789[(unsigned __int8)EPass[2]] &gt;&gt; 2) | 16 * a456789[(unsigned __int8)EPass[1]];
v7 = (unsigned __int8)EPass[2];
v8 = (unsigned __int8)EPass[3];
EPass += 4;
passEncode[2] = (a456789[v7] &lt;&lt; 6) | a456789[v8];
passEncode += 3;
  }
  if ( v4 &gt; 1 )
  {
*passEncode = ((unsigned __int8)a456789[(unsigned __int8)EPass[1]] &gt;&gt; 4) | 4 * a456789[(unsigned __int8)*EPass];
if ( v4 == 2 )
{
  v6 = passEncode + 1;
}
else
{
  passEncode[1] = ((unsigned __int8)a456789[(unsigned __int8)EPass[2]] &gt;&gt; 2) | 16
 * a456789[(unsigned __int8)EPass[1]];
  if ( v4 == 4 )
  {
v6 = passEncode + 3;
passEncode[2] = (a456789[(unsigned __int8)EPass[2]] &lt;&lt; 6) | a456789[(unsigned __int8)EPass[3]];
  }
  else
  {
v6 = passEncode + 2;
  }
}
  }
  *v6 = 0;
  return v5 - (-v4 &amp; 3);
}
</code></pre>

<p>眼尖的，应该可以看出来这是base64，我眼不尖，问了下23333（咳咳，看来我还需要巩固下密码学的一些基础）</p>
<p><img src="./Image/6.png" /></p>
<p>这个其实就是base64的编码表的起始位置，双击进去查看
<img src="./Image/7.png" />
然后在Hex窗口查看</p>
<p>用一个十六进制编辑器打开：</p>
<p><img src="./Image/9.png" /></p>
<p>右键-&gt;Edit-&gt;Copy block-&gt;C source</p>
<p>然后根据条件&quot;&lt;=0x3f&quot;
，写一个c脚本：</p>
<pre><code>// keygen.cpp : 定义控制台应用程序的入口点。
//

#include &quot;stdafx.h&quot;
#include&lt;iostream&gt;
using namespace std;

unsigned table[] = {
0x3E, 0x40, 0x40, 0x40, 0x3F, 0x34,
0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41,
0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51,
0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F, 0x00,
0x00, 0x00, 0x00, 0x00
};

int main()
{

unsigned a;
for (int i = 0; i &lt;= 0xff; i++) {
    a = table[i];
    if (a &lt;= 0x3f) {
        cout &lt;&lt; &quot;input&quot; &lt;&lt; hex &lt;&lt; i &lt;&lt; &quot; ,value:&quot; &lt;&lt; a &lt;&lt; endl;
    }
}
system(&quot;pause&quot;);
return 0;


}
</code></pre>

<p>编码表的对应关系：</p>
<p><img src="./Image/8.png" /></p>
<p>然后写一个注册机：</p>
<p>这里直接拿看雪上面别人写的，附上原文链接，这个大佬是分析汇编（膜拜）
<a href="http://bbs.pediy.com/thread-208933.htm">http://bbs.pediy.com/thread-208933.htm</a></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
