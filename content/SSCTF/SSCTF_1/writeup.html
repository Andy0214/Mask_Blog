<!DOCTYPE html>
<html>
<head>
<title>writeup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Write up</h2>
<p>先看AndroidManifest，纯属习惯问题：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest package=&quot;com.seclover.ctf1&quot; platformBuildVersionCode=&quot;24&quot; platformBuildVersionName=&quot;7.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;22&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;
&lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.Main&quot; android:screenOrientation=&quot;portrait&quot;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;/application&gt;
&lt;/manifest&gt;
</code></pre>

<p>这里有两条权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;  //允许挂载和反挂载文件系统
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    //允许写入外部存储
</code></pre>

<h2>以上全属废话，和解题无关</h2>
<p>跟进入口类：</p>
<p>这里一般都会先找onCreate()方法</p>
<p>这里有一些资源文件需要找到对应的，我这里就直接给出注释了</p>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    boolean isEncrypted = false;
    System.out.println(&quot;BuildConfig.DEBUGfalse&quot;);
    super.onCreate(savedInstanceState);
    setContentView(R.layout.preference);
    this.flagView = (EditText) findViewById(R.id.c);
    this.hint = (TextView) findViewById(R.id.e);
    final Button submit = (Button) findViewById(R.id.d);
    this.pref = getSharedPreferences(&quot;ctf1&quot;, 0);//设置SharedPreferences文件 在/data/data/com.seclover.ctf1/shared_prefs/目录下
    if (this.pref.getInt(&quot;isEncrypted&quot;, 0) != 0) {//如果isEncrypted的值不为0
        isEncrypted = true;//设置true
    }
    if (isEncrypted) {
        this.hint.setText(R.string.hint_encrypted);//文档已加密,请联系xxx解密.
        submit.setText(R.string.btn_text_decrypt);//解密
    } else {
        this.hint.setText(R.string.hint_set_pwd);//请设置一个6位数密码,然后才能进入应用
        submit.setText(R.string.btn_text_set_pwd);//设置密码
    }
    submit.setOnClickListener(new OnClickListener() {
        public void onClick(View v) { //设置按钮点击事件
            boolean isEncrypted;
            Main.this.pref = Main.this.getSharedPreferences(&quot;ctf1&quot;, 0);
            if (Main.this.pref.getInt(&quot;isEncrypted&quot;, 0) != 0) {
                isEncrypted = true;
            } else {
                isEncrypted = false;
            }
            if (!isEncrypted) {
                String key = Main.this.flagView.getText().toString();
                if (key == null || key.isEmpty() || key.length() != 6) {//输入的key满足其中一个
                    Toast.makeText(Main.this, R.string.input_len_not_enough, 0).show();//输入不能为空或长度不正确！
                    return;
                }
                Main.this.check(Main.this.flagView.getText().toString());
                Main.this.hint.setText(R.string.hint_encrypted);//文档已加密,请联系xxx解密.
                submit.setText(R.string.btn_text_decrypt);//解密
                Main.this.saveState(Main.this.pref, 1);
            } else if (Main.this.check2(Main.this.flagView.getText().toString())) {
                Toast.makeText(Main.this, R.string.try_face_swiping, 0).show();//刷脸试试!
            } else {
                Toast.makeText(Main.this, R.string.try_shout, 0).show();//大喊一声解锁试试!
            }
        }
    });
}
</code></pre>

<p>那么接着跟进check方法：</p>
<pre><code>private boolean check(String key) {
        if (!verify(getSign(this), this.SIGN_MD5)) {
            return false;
        }
        for (int i = 0; i &lt; 100; i++) {
                for (int j = 0; j &lt; 100; j++) {
                    this.k1[((i + 17) * (j + 5)) % this.k1.length] = (byte) ((this.k1[(i * j) % this.k1.length] ^ (key.charAt((i * j) % key.length()) * 7)) % TransportMediator.KEYCODE_MEDIA_PAUSE);
                }
        }
        encode(this);
        return true;
}
</code></pre>

<p>跟进verify：</p>
<pre><code>private boolean verify(String key1, String key2) {
    int i;
    this.k1 = ToolsUtils.SHA(key1).getBytes();
    byte[] k2 = ToolsUtils.SHA(key2).getBytes();
    for (i = 0; i &lt; this.k1.length; i++) {
        for (int j = 0; j &lt; k2.length; j++) {
            this.k1[(((i * j) * 7) + 9) % this.k1.length] = (byte) ((this.k1[i] ^ (j * 5)) % TransportMediator.KEYCODE_MEDIA_PAUSE);
            k2[(((i * j) * 7) + 9) % k2.length] = (byte) ((k2[i] ^ (j * 5)) % TransportMediator.KEYCODE_MEDIA_PAUSE);
        }
    }
    boolean isBreak = false;
    int len = this.k1.length &gt; k2.length ? k2.length : this.k1.length;
    for (i = 0; i &lt; len; i++) {
        if (((this.k1[i] ^ k2[i]) ^ this.k1[i]) != this.k1[i]) {
            isBreak = true;
            break;
        }
    }
    if (isBreak) {
        return false;
    }
    return true;
}
</code></pre>

<p>和getSign：</p>
<pre><code>private String getSign(Context context) {
    return ToolsUtils.getSignInfo(context, &quot;com.seclover.ctf1&quot;);//可以看到这里调用了ToolsUtils类，那么我们跟进查看
}
</code></pre>

<p>继续跟进，别看花眼了2333</p>
<p><img src="./Image/1.png" /></p>
<pre><code>public static String getSignInfo(Context context, String pkName) {
    try {
        return md5(Integer.toString(context.getPackageManager().getPackageInfo(pkName, 64).signatures[0].hashCode(), 16));
    } catch (Exception e) {
        e.printStackTrace();
        return &quot;invalid&quot;;
    }
}
</code></pre>

<p>看看这个MD5方法：</p>
<pre><code>public static String md5(String string) {
    try {
        byte[] hash = MessageDigest.getInstance(&quot;MD5&quot;).digest(string.getBytes(&quot;utf-8&quot;));
        StringBuilder hex = new StringBuilder(hash.length * 2);
        for (byte b : hash) {
            if ((b &amp; 255) &lt; 16) {
                hex.append(&quot;0&quot;);
            }
            hex.append(Integer.toHexString(b &amp; 255));
        }
        return hex.toString().toLowerCase(Locale.CHINA);//
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(&quot;Huh, MD5 should be supported?&quot;, e);
    } catch (UnsupportedEncodingException e2) {
        throw new RuntimeException(&quot;Huh, UTF-8 should be supported?&quot;, e2);
    }
}
</code></pre>

<p>然后接着跟进encode：</p>
<pre><code>private boolean encode(Context context) {
    File fileR = new File(Environment.getExternalStorageDirectory(), DEFAULT_FILENAME_SRC);//ctf1.xlsx
    if (!fileR.exists()) {
        return false;
    }
    try {
        FileOutputStream fos = new FileOutputStream(new File(Environment.getExternalStorageDirectory(), DEFAULT_FILENAME_ENCODE));//ctf1_encode.xlsx
        FileInputStream fis = new FileInputStream(fileR);
        byte[] b = new byte[fis.available()];
        fis.read(b);
        for (int i = 0; i &lt; b.length; i += 256) {
            b[i] = (byte) (b[i] ^ this.k1[i % this.k1.length]);
        }
        fos.write(b);
        fos.close();
        fis.close();
        fileR.delete();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return true;
}
</code></pre>

<p>那么流程大致清楚了，这里简单说下</p>
<p>将输入的的密码作为参数传入check方法，然后check方法里面调用了一次verify，作用就是判断应用的包名信息通过MD5加密后，是否等于SIGN_MD5。</p>
<p>并且在verify中同时对k1数组进行了初始化，开始瞄了半天没找到在哪赋值的</p>
<p>然后在check这里将k1进行一个处理，得到一个新的k1</p>
<pre><code>for (int i = 0; i &lt; 100; i++) {
    for (int j = 0; j &lt; 100; j++) {
        this.k1[((i + 17) * (j + 5)) % this.k1.length] = (byte) ((this.k1[(i * j) % this.k1.length] ^ (key.charAt((i * j) % key.length()) * 7)) % TransportMediator.KEYCODE_MEDIA_PAUSE);
    }
}
</code></pre>

<p>然后调用了encode方法，作用就是将这个新的k1和ctf1_encode.xlsx文件进行异或，没0x100个字节异或一下。</p>
<p>呐，这就是大致的流程</p>
<hr />
<p>那么开始解密操作，既然是异或加密了，那么我们在异或一次就能解密，讲道理是这样的，但是我们并不知道这个新的k1是多少，这里回忆一下这个新的k1怎么来的</p>
<p>第一步</p>
<pre><code>this.k1 = ToolsUtils.SHA(key1).getBytes();
</code></pre>

<p>第二步：</p>
<pre><code>this.k1[(((i * j) * 7) + 9) % this.k1.length] = (byte) ((this.k1[i] ^ (j * 5)) % 127);
</code></pre>

<p>第三步：</p>
<pre><code>this.k1[((i + 17) * (j + 5)) % this.k1.length] = (byte) ((this.k1[(i * j) % this.k1.length] ^ (key.charAt((i * j) % key.length()) * 7)) % 127);
</code></pre>

<p>那么，讲道理是通过key1然后各种变换来的</p>
<p>逆回去？，不存在的好吧。这里我当时也思考了半天。。。。没办法，做题经验太少，略略略</p>
<p>然后其实看了一下大佬写的writeup，然后自己再顺着思路解的23333</p>
<p>呐，大致思路就是爆破，爆破啥？通过爆破那个输入的6位数的值</p>
<p>这里先看看一下那个加密的xlsx文件的格式和正常xlsx文件（这里随便新建一个就行我偷了下懒，拿解密好了的对比。。。懒得再去新建了23333）的区别</p>
<p><img src="./Image/2.png" /></p>
<p>不同处红色标明出来了</p>
<p>0x00，0x100,0x200,0x300,0x400,0x500处，我们看前几个就够了，
那么爆破的思路就是</p>
<p>通过爆破那个6位密码 -&gt; 得到k1 -&gt; 各种变换得到那个新的k1 -&gt; 然后再和加密的xlsx异或一次 -&gt;得到解密后的原文件</p>
<p>这里给出解题代码，大部分都是题目里给的。。。分析下即可得出，主要是那个爆破以及xlsx的几处标志位，那才是关键</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class test {

static byte[] k1;
static String MD5_KEY = &quot;a056d5ab1fa5c250c293a5b7588d0749&quot;;

public static void main(String[] args) throws Exception {
    for(int i = 100000; i &lt; 999999; i++) {

        verify(String.valueOf(i),MD5_KEY);

        if(check(String.valueOf(i), i)) {
            System.out.println(&quot;Find it : ctf1_decode_&quot; + i + &quot;.xlsx&quot;);
        }
    }
}



private static boolean verify(String key,String key2) {
    k1 = ToolsUtils.SHA(key).getBytes();
    byte[] k2 = ToolsUtils.SHA(key2).getBytes();

    for(int i = 0; i &lt; k1.length; i++) {
        for(int j = 0; j &lt; k1.length; j++) {
            k1[(i * j * 7 + 9) % k1.length] = ((byte)((k1[i] ^ j * 5) % 127));
            k2[(((i * j) * 7) + 9) % k2.length] = (byte) ((k2[i] ^ (j * 5)) % 127);

        }
    }
    boolean isBreak = false;
    int len = k1.length &gt; k2.length ? k2.length : k1.length;
    for (int i = 0; i &lt; len; i++) {
        if (((k1[i] ^ k2[i]) ^ k1[i]) != k1[i]) {
            isBreak = true;
            break;
        }
    }
    if (isBreak) {
        return false;
    }
    return true;

}



private static boolean check(String key, int index) {
    for(int i = 0; i &lt; 100; i++) {
        for(int j = 0; j &lt; 100; j++) {
            k1[(i + 17) * (j + 5) % k1.length] = ((byte)((k1[i * j % k1.length] ^ key.charAt(i * j % key.length()) * 7) % 127));
        }
    }
    if(test.decode(k1, index)) {
        return true;
    }
    return false;
}

private static boolean decode(byte[] key, int index) {
    try {

        File file = new File(&quot;D:\\ctf1_encode.xlsx&quot;);
        if (!file.exists()) {
            System.out.println(&quot;file does not exist&quot;);
            return false;
        }
        FileInputStream fileInputStream = new FileInputStream(file);
        byte[] temp = new byte[fileInputStream.available()];
        fileInputStream.read(temp);
        for(int i = 0; i &lt; temp.length; i += 256) {
            temp[i] = ((byte)(temp[i] ^ key[i % key.length]));//再异或一次，即可解密
        }
        if ((temp[0x00] != 'P')//判断是否为一个符合格式的xls文件
                || (temp[0x100] != 0x00)
                || (temp[0x200] != 0x00)
                || (temp[0x400] != 0x00)
                || (temp[0x500] != 0x00)) {
            fileInputStream.close();
            return false;
        }
        File output = new File(index+&quot;ctf1_decode_.xlsx&quot; );
        FileOutputStream fileOutputStream = new FileOutputStream(output);
        fileOutputStream.write(temp);
        fileOutputStream.close();
        fileInputStream.close();
        System.out.println(&quot;key:&quot;+index);//输入的key
    }
    catch(Exception e) {
        e.printStackTrace();
    }
    return true;
    }
}
</code></pre>

<p>然后输出，key就是爆破出来的6位密码</p>
<pre><code>&quot;C:\Program Files\Java\jdk1.8.0_102\bin\java&quot; -Didea.launcher.port=7532 &quot;-Didea.launcher.bin.path=I:\IntelliJ IDEA Community Edition 2016.3\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\Program Files\Java\jdk1.8.0_102\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_102\jre\lib\rt.jar;C:\Users\mask\Desktop\SSCTF\SSCTF_1\key\out\production\key;I:\IntelliJ IDEA Community Edition 2016.3\lib\idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain test
key:112355
Find it : ctf1_decode_112355.xlsx
key:179351
Find it : ctf1_decode_179351.xlsx
</code></pre>

<p>答案应该不止两个的，这里等了一下不想等了，就停止运行了，反正答案出来了</p>
<p><img src="./Image/3.png" /></p>
<p>总结一下，学到了一些解题套路，然后还有就是不要被题目牵着走。这题有一点就是那个算包名的MD5的值然后比较，分析一下啊，肯定要，必须要，一定要相等的啊，不然你怎么搞嘞，不要傻乎乎的真的去算一下包名的MD5值，你算了的话，会发现就和前面给的<code>private String SIGN_MD5 = &quot;a056d5ab1fa5c250c293a5b7588d0749&quot;;</code>一毛一样，看到还有说啥用jeb动态调试一下得出来的。（其实我倒拿IDEA调试了下smali，验证一下，确实一样）</p>
<p><img src="./Image/4.png" />
浪费时间。。。。。。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
